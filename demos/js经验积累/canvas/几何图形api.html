<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>几何图形api</title>
		<link rel = "stylesheet" href = "css/base.css"/>
		<style>
			canvas{
				border:2px solid #00f;
				margin: 50px auto;
				width: 500px;
				display: block;

			}
		</style>
	</head>
	<body>
		<div class ="content clearfix">
			<canvas id = "cav1" height = "500" width = "500"></canvas> 
			<canvas id = "cav2" height = "500" width = "500"></canvas> 
			<canvas id = "cav3" height = "500" width = "500"></canvas> 
			<canvas id = "cav4" height = "500" width = "500"></canvas> 
			
		</div>
		<script type="text/javascript" src = "js/jquery-1.7.1.js"></script>
		<script>
			/*
				矩形
					空心矩形
					rect(x,y,width,height)
					stroke()
					实心矩形
					fillRect()
					清除矩形
					clearRect(x,y,w,h)

				多边形
					貌似没现成的api,自己弄一个
				弧形，圆形
					arc(x,y,半径,开始角度，结束角度，是否逆时针旋转)
					arcTo(x1,y1,x2,y2,半径)
				二元抛物线
					这条曲线从当前点开始，到 (x,y) 结束。控制点 (cpX,cpY) 说明了这两个点之间的曲线的形状
				quadraticCurveTo(cp1x, cp1y, x, y)

			*/
			var canvas1 = $("#cav1"),
				ctx = canvas1[0].getContext('2d');

			ctx.fillStyle = "#f00";
			ctx.fillRect(0,0,10,10);

			ctx.beginPath();
			ctx.lineWidth = 3;
			ctx.rect(20,20,50,50);
			ctx.stroke();//无这步就画不出矩形
			ctx.strokeStyle = "#0f0";
			ctx.fill();
			//ctx.endPath();

			
			ctx.clearRect(20,20,10,10);
			ctx.beginPath();//结束上次的的绘制，可以注释这行看看。 ctx.endPath();之后，beginPath也没用
			var startAngle =0,
				endAngle = Math.PI*(1/2);
			ctx.arc(150,150,50,startAngle,endAngle,false);
			ctx.strokeStyle = "#00f";
			ctx.stroke();
			//ctx.endPath();

			var canvas2 = $("#cav2"),
				ctx = canvas2[0].getContext('2d');
			ctx.beginPath();
			ctx.moveTo(20,20);
			ctx.arc(150,150,50,startAngle,endAngle,false);//从x轴正方向上为0度点
			ctx.stroke();

			ctx.beginPath();
			ctx.moveTo(50,50);
			ctx.arcTo(290,150,20,280,20);
			ctx.lineTo(20,280);
			//ctx.closePath();//closePath 必须在stoke之前在被调用
			ctx.stroke();
			//ctx.closePath();
			//ctx.fill();

			var canvas3 = $("#cav3"),
				ctx = canvas3[0].getContext('2d');
			drawPolygon(ctx,[{
				x:10,
				y:10
			},
			{
				x:20,
				y:20
			},
			{
				x:20,
				y:70
			},
			{
				x:10,
				y:70
			}
			]);
			drawPolygon(ctx,[{
				x:110,
				y:10
			},
			{
				x:120,
				y:20
			},
			{
				x:120,
				y:70
			},
			{
				x:110,
				y:70
			}
			]);
			function drawPolygon(ctx,points){
				var i = 1,
					length;
				if(points && points.length > 0){
					ctx.beginPath();
					ctx.moveTo(points[0].x,points[0].y);
					for(length= points.length;i<points.length;i++){
						ctx.lineTo(points[i].x,points[i].y);
					}
					ctx.stroke();

				}
			}



			var canvas4= $("#cav4"),
				ctx = canvas4[0].getContext('2d');
			drawShape(ctx);
			drawShape2(ctx);
			//
			function drawShape(ctx){
			    // Draw shapes
			    ctx.beginPath();
			    ctx.moveTo(75,25);
			    ctx.quadraticCurveTo(25,25,25,62.5);
			    ctx.quadraticCurveTo(25,100,50,100);
			    ctx.quadraticCurveTo(50,120,30,125);
			    ctx.quadraticCurveTo(60,120,65,100);
			    ctx.quadraticCurveTo(125,100,125,62.5);
			    ctx.quadraticCurveTo(125,25,75,25);
			    ctx.stroke();
			    return;

			 
			}
			function drawShape2(ctx){
			 
			    // Draw shapes

			    ctx.beginPath();
			    ctx.moveTo(275,240);
			    ctx.bezierCurveTo(75,37,70,25,50,25);
			    ctx.bezierCurveTo(20,25,20,62.5,20,62.5);
			    ctx.bezierCurveTo(20,80,40,102,75,120);
			    ctx.bezierCurveTo(110,102,130,80,130,62.5);
			    ctx.bezierCurveTo(130,62.5,130,25,100,25);
			    ctx.bezierCurveTo(85,25,75,37,75,40);
			    ctx.fill();
			}
			
		</script>
	</body>
</html>